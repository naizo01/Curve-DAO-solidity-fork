
# Curve DAO 解説

Curve DAOで実装されている各コントラクトの概要と、それらがどのような処理を行っているのかを説明します。

背景として、Curve DAOコントラクト群は、Vyperで記述されていますが、最近Solidityに書き換える機会がありました。そこで学んだことを備忘録も兼ねてまとめていきます。

## Curve DAOの主要な機能

1. **流動性提供者へのインセンティブ**: Curve DAOは、流動性提供者にCRVトークンを配布することで、プロトコルへの流動性提供を奨励します。

2. **ガバナンス**: CRVトークンを保有するユーザーは、プロトコルの重要な意思決定に参加することができます。これには、手数料の変更、新しいプールの追加、プロトコルのアップグレードなどが含まれます。

3. **手数料の分配**: Curve DAOは、プロトコルが徴収する手数料の一部をCRVトークンの保有者に分配します。これにより、トークン保有者はプロトコルの成長から直接的な恩恵を受けることができます。

4. **ゲージ（Gauge）システム**: Curve DAOは、ゲージシステムを通じてCRV報酬の分配を制御します。ゲージは流動性プールごとに設定され、CRVトークンの保有者は投票を通じてゲージの重みを決定します。

### veCRVのメカニズム

veCRVは、CRVトークンをVotingEscrowコントラクトにロックすることでのみ得られる特別なトークンです。これは購入や譲渡ができない特性を持ち、ユーザーは自分の保有しているCRVトークンを選択可能な期間（最大4年）でロックすることによりveCRVトークンを得ることができます。veCRVの量は、ロックされるCRVの量とロック期間に基づいて計算され、時間が経つほど線形に減少します。

### CRVロックのインセンティブ

CRVをロックすることによる主なインセンティブは、Curve DAO内での影響力を増加させることです。veCRVを持つことにより、ユーザーはLiquidity GaugeのWeightを決定する権利を持つことになります。これにより、特定のプールがCRVトークンの排出量のどの程度を受け取るかを決定できます。したがって、ユーザーはCRVをロックすることで自分の投資を最大化するだけでなく、Curveエコシステム全体の方向性に影響を与えることができるのです。

### ブーストとは

ブーストは、veCRVを持つユーザーがCRV報酬を増やすことができる仕組みです。ユーザーがより多くのveCRVを持っているほど、そのユーザーのLiquidityGaugeにステークされたLPトークンに対するCRV報酬が最大2.5倍までブーストされます。これにより、長期的にCRVをロックしているユーザーは、より多くのCRV報酬を獲得することができます。




### CRV供給量とその分配

CRVトークンの初期供給量は1.3億CRVで、最終的な供給量は3.03億CRVとされています。流動性提供者には62%が割り当てられており、流動性提供者が受け取るCRVの排出量は年々減少していきます。

### Liquidity Gaugeとブースティング

CRVトークンは、ユーザーが流動性を提供することによって配布されます。この配布量はLiquidity Gaugeによって測定され、ユーザーはLPトークンをLiquidity Gaugeにデポジットする必要があります。CRVの受け取り量は、Liquidity GaugeのWeightに基づいて決定され、veCRVの保有量に応じてブーストされます。

ブーストの仕組みは以下の通りです：

1. ユーザーがveCRVをロックすることで、そのユーザーのLiquidity Gaugeにデポジットされたトークンの量に基づいて、CRV報酬が最大2.5倍までブーストされます。

2. ブースト係数は、ユーザーのveCRVの量とロック期間に基づいて計算されます。ロック期間が長いほど、ブースト係数は高くなります。

3. ブーストされたCRV報酬は、ユーザーがLiquidity Gaugeからトークンを引き出すか、ロック期間が終了するまで適用されます。

このブースト機能により、veCRVの保有者は、より多くのCRV報酬を受け取ることができます。一方で、veCRVを持たないユーザーは、ブーストされていない通常のCRV報酬を受け取ることになります。

### ゲージの重み付けと投票

1. ゲージの重み付け：GaugeControllerは、各Liquidity Gaugeに重みを割り当てます。この重みは、そのゲージに割り当てられるCRV報酬の量を決定します。重みは、veCRVホルダーの投票によって決定され、定期的に更新されます。

2. ゲージのタイプ管理：GaugeControllerは、ゲージをタイプ別に分類し、各タイプに重みを割り当てます。これにより、特定のタイプのゲージ（例えば、ステーブルコインプールのゲージ）に対して、より多くのCRV報酬を割り当てることができます。

3. CRV報酬の計算：GaugeControllerは、各ゲージに割り当てられたCRV報酬の量を計算します。この計算は、ゲージの重み、タイプの重み、およびCRVの総排出量に基づいて行われます。

4. ゲージの追加と管理：GaugeControllerは、新しいゲージの追加や既存のゲージの管理を行います。これには、ゲージのアドレスの管理、ゲージのタイプの割り当て、およびゲージの有効化/無効化が含まれます。

5. ユーザーの投票の管理：GaugeControllerは、veCRVホルダーによるゲージへの投票を管理します。各ユーザーは、自分のveCRVの量に応じて投票権を持ち、それを使って特定のゲージに重みを割り当てることができます。

GaugeControllerは、これらの処理を通じて、CRV報酬の分配を制御し、ユーザーにゲージへの投票を行うインセンティブを与えています。これにより、Curveプロトコルの流動性が最適化され、ユーザーにとって最も有益なプールに報酬が配分されるようになっています。

## Curve DAO 各コントラクトの概要

Curve DAOの全体構成を理解するために、それぞれのコントラクトの役割と機能について説明します。

以下の図は、Curve DAOの全体構成を示しています。
![Curve DAO Overview](https://raw.githubusercontent.com/curvefi/curve-dao-contracts/567927551903f71ce5a73049e077be87111963cc/doc/dao-overview.svg)

### CRV.sol

CRV.solは、Curve FinanceのネイティブトークンであるCRVを管理するコントラクトです。CRVは、ユーザーが流動性を提供することで獲得できるトークンで、Curve DAOでの投票権を持ちます。CRVの総供給量は決まっていて、時間が経つにつれて新しく発行されるCRVの量が減少していく設計になっています。

### VotingEscrow.sol

VotingEscrow.solは、ユーザーがCRVをロックして投票権を獲得するためのコントラクトです。ユーザーは、CRVを一定期間（最大4年）ロックすることで、ロック期間に応じたveCRV（vote-escrowed CRV）を受け取ります。veCRVは、CRVをアンロックするまでの間、投票権を持ちます。ロック期間が長いほど、より多くのveCRVを獲得できます。

### GaugeController.sol

GaugeController.solは、各流動性プールに対してゲージ（Gauge）を管理し、CRVの分配を制御するコントラクトです。ゲージは、流動性プールごとに設定され、そのプールに割り当てられるCRV報酬の量を決定します。veCRVを持つユーザーは、どのゲージにどれだけのCRVを割り当てるかを投票することができます。

### LiquidityGauge.sol

LiquidityGauge.solは、ユーザーが流動性を提供するとCRV報酬を受け取ることができるコントラクトです。ユーザーは、流動性プールのLPトークンをLiquidityGaugeにステークすることで、CRV報酬を獲得します。各ユーザーの報酬額は、ステークしたLPトークンの量とゲージの重みに基づいて計算されます。

### Minter.sol

Minter.solは、LiquidityGaugeからのリクエストに基づいてCRVを鋳造するコントラクトです。LiquidityGaugeは、ユーザーにCRV報酬を配布するために、Minterに新しいCRVの鋳造をリクエストします。

### FeeDistributor.sol

FeeDistributor.solは、Curveプロトコルが徴収する手数料の50%をveCRVホルダーに分配するコントラクトです。手数料は、3CRVトークン（Curve's 3pool LP token）で回収され、毎週veCRVホルダーに分配されます。各ユーザーの受け取り額は、そのユーザーのveCRVの量が全体のveCRVの量に占める割合に基づいて計算されます。


## 用語解説

### エポック（Epoch）

システムの状態が更新される特定の時点を指します。これは、ユーザーの投票権や流動性ゲージの状態が変更される際に、その変更を記録するために使用されるタイムスタンプです。エポックは、システム全体の歴史的な状態を追跡し、時間経過に伴う変更を管理するのに役立ちます。

### スロープ（Slope）

ユーザーの投票力が時間とともにどのように減少するかを示す指標です。具体的には、ユーザーがトークンをロックするときに設定され、ロックされたトークンの量とロック期間に基づいて計算されます。スロープは、投票権の減少率を表し、時間経過に伴う投票重みの変化を定量化します。

### チェックポイント（Checkpoint）

ユーザーのトークンロックや投票権の変更点を記録するために使用されるマーカーです。これは、ユーザーがトークンをロックしたり、ロックを解除したり、またはロック期間を変更したりする際に、その変更を正確に追跡するために重要です。チェックポイントを通じて、システムは過去の任意の時点でのユーザーの投票権を正確に計算することができます。

### バイアス（Bias）

特定の時点でのユーザーの投票重みを意味します。これは、ユーザーがトークンをロックすることで得られる初期の投票力を表し、時間が経過するにつれて徐々に減少します（スロープによって決定される）。バイアスは、ユーザーの投票権の現在の強度を示します。


## VotingEscrow コントラクト解説

ここからソースコードを参照しながら、VotingEscrowコントラクトの重要な部分について詳しく解説していきます。

### ユーザーが操作する主要な関数

1. **`createLock(uint256 value_, uint256 unlockTime_)`**:
    - ユーザーが指定した量のトークン（`value_`）を特定の期間（`unlockTime_`まで）ロックするために使用されます。
    - ユーザーは新しいロックを作成する際にこの関数を呼び出し、トークンをVotingEscrowコントラクトに預けます。
    - ロック期間は週単位で丸められ、最大4年間のロックが可能です。

2. **`increaseAmount(uint256 value_)`**:
    - 既存のロックにトークン（`value_`）を追加するために使用されます。
    - ユーザーはこの関数を通じて、ロック期間を変更せずにロックされているトークンの量を増やすことができます。
    - ロック期間が過ぎているロックには追加できません。

3. **`increaseUnlockTime(uint256 unlockTime_)`**:
    - 既存のロックの期間を延長するために使用されます。
    - ユーザーはこの関数を呼び出すことで、ロックされたトークンが解放される時刻（`unlockTime_`）を延長することができます。
    - 新しいロック期間は、現在のロック期間より長くなければならず、最大4年間までです。

4. **`withdraw()`**:
    - ユーザーがロックされたトークンを解放し、引き出すために使用されます。
    - ロック期間が終了した後にのみ、ユーザーはこの関数を呼び出してトークンを引き出すことができます。

これらの関数は、ユーザーによって直接呼び出されるもので、トークンのロック状態を変更します。

### コントラクトで使用される主要なデータ構造

#### `Point`
```solidity
struct Point {
    int128 bias;
    int128 slope; // - dweight / dt
    uint256 ts; //timestamp
    uint256 blk; // block
}
```
`Point`構造体は、ある時点でのトークンの総量（`bias`）とその変化率（`slope`）を表現するために使用されます。`ts`はタイムスタンプ、`blk`はブロック番号を表します。

#### `LockedBalance`
```solidity
struct LockedBalance {
    int128 amount;
    uint256 end;
}
```
`LockedBalance`構造体は、各ユーザーのロック状態を表現するために使用されます。`amount`はロックされているトークンの量、`end`はロック期間の終了時刻を表します。

### 主要な状態変数

#### `epochʻ
- グローバルなチェックポイント（時点）の数を追跡します。
- コントラクトの状態が更新されるたびに増加します。

#### `pointHistory`
```solidity
mapping(uint256 => Point) public pointHistory;
```
- グローバルな投票パワーの履歴を保存するマッピングです。
- `epoch`をキーとして、各時点での`Point`（`bias`と`slope`）を保存します。

#### `userPointHistory`
```solidity
mapping(address => mapping(uint256 => Point)) public userPointHistory;
```
- 各ユーザーの投票パワーの履歴を保存するマッピングです。
- ユーザーのアドレスと`epoch`をキーとして、各時点での`Point`（`bias`と`slope`）を保存します。

#### `slopeChanges`
```solidity
mapping(uint256 => int128) public slopeChanges;
```
- 特定の時点で発生するスロープの変更を保存するマッピングです。
- 時刻をキーとして、その時点でのスロープの変化量を保存します。

### `_checkpoint`関数の解説

```solidity
function _checkpoint(
    address addr_,
    LockedBalance memory oldLocked_,
    LockedBalance memory newLocked_
) internal
```

`_checkpoint`関数は、ユーザーのロック状態が変更されたときに呼び出され、グローバルとユーザーの投票パワーの履歴を更新します。

主な処理の流れは以下の通りです：

1. 古いロック状態と新しいロック状態から、`slope`と`bias`を計算します。
2. グローバルな`slope`の変更を読み取ります。
3. グローバルな投票パワーの履歴を更新します。
   - 現在のブロック時刻まで、1週間ごとに`Point`を作成し、`pointHistory`に保存します。
   - 各`Point`では、前の`Point`からの`slope`と`bias`の変化を反映させます。
4. ユーザーの投票パワーの履歴を更新します。
   - ユーザーの`slope`と`bias`を更新し、`userPointHistory`に保存します。
   - ロック期間の終了時に発生する`slope`の変更を、`slopeChanges`に記録します。

この関数によって、グローバルとユーザーの投票パワーの履歴が正確に管理されます。これにより、任意の時点での投票パワーを効率的に計算することが可能になります。

### 投票パワーの計算

VotingEscrowコントラクトでは、ユーザーの投票パワーを以下のように計算します：

1. ユーザーの現在の`Point`を取得します。
2. 現在のブロック時刻と`Point`の`ts`の差分を計算します。
3. `Point`の`bias`から、`slope`と時間差分の積を減算します。
4. 結果が負の場合は0に切り上げます。

この計算は、`balanceOf`関数や`balanceOfAt`関数内で行われ、指定された時点でのユーザーの投票パワーを返します。

また、グローバルな投票パワーの合計値は、`totalSupply`関数や`totalSupplyAt`関数で計算されます。これらの関数では、指定された時点に対応する`epoch`を二分探索で見つけ、そこから線形補間を行うことで任意の時点での合計値を求めています。

### まとめ

VotingEscrowコントラクトは、ユーザーがトークンをロックすることで投票パワーを獲得し、ガバナンスに参加できる仕組みを提供します。

コントラクトでは、グローバルとユーザーごとの投票パワーの履歴が`Point`構造体の形で保存され、`_checkpoint`関数によって更新されます。これにより、任意の時点での投票パワーを効率的に計算することが可能になります。

ユーザーは、`createLock`、`increaseAmount`、`increaseUnlockTime`、`withdraw`などの関数を呼び出すことで、自分のトークンをロックしたり、ロック状態を変更したりすることができます。

VotingEscrowコントラクトは、Ve tokenモデルの中核をなす重要な部分であり、DeFiプロトコルのガバナンスを支える基盤となっています。

## CRV コントラクト解説

### `rate`変数の説明
CRVトークンのコントラクト内の`rate`変数は、CRVトークンのマイニング（発行）率を表します。この値は、一定の時間間隔（エポックと呼ばれる）ごとに更新され、トークンの新規発行量を決定します。初期の`rate`は`(274_815_283 * 10 ** 18) / YEAR`として定義されており、これはCRVの初期供給量に基づいて計算されます。時間が経過するにつれて、この発行率は減少し、トークンのインフレを抑制する役割を果たします。

### `_updateMiningParameters`関数の説明
`_updateMiningParameters`は内部関数であり、CRVトークンのマイニングパラメータを更新するために使用されます。この関数は、新しいマイニングエポックの開始時に呼び出され、以下のステップでマイニング率（`rate`）と供給量を更新します。

1. **エポックの更新**: `startEpochTime`変数が更新され、新しいエポックの開始時刻が設定されます。同時に、`miningEpoch`変数がインクリメントされ、新しいエポックを追跡します。

```solidity
uint256 _rate = rate;
uint256 _startEpochSupply = startEpochSupply;

startEpochTime += RATE_REDUCTION_TIME;
miningEpoch += 1;

```

2. **マイニング率の計算**: 最初のエポックでは`rate`は`INITIAL_RATE`に設定されます。以降のエポックでは、現在の`rate`が`RATE_REDUCTION_COEFFICIENT (2 ** (1/4) * 1e18)`で割られることにより、新しいマイニング率が計算されます。これにより、トークンの発行量は徐々に減少します。

```solidity
if (_rate == 0) {
    _rate = INITIAL_RATE;
} else {
    _startEpochSupply += _rate * RATE_REDUCTION_TIME;
    startEpochSupply = _startEpochSupply;
    _rate = (_rate * RATE_DENOMINATOR) / RATE_REDUCTION_COEFFICIENT;
}

rate = _rate;
```

この関数はCRVの供給量を調整し、インフレ率を制御する重要な役割を果たします。また、任意のアドレスがこの関数を呼び出すことができますが、エポックの更新が必要な時にのみ有効です。

### `futureEpochTimeWrite`関数による`rate`の更新
`futureEpochTimeWrite`関数は、CRVトークンの次のマイニングエポックの開始時刻を取得し、同時にマイニングパラメータを更新することができます。この関数は、Liquidity Gaugeのチェックポイントで呼び出されることがあり、運営による直接的な介入なしに、ユーザーのトランザクションによって`rate`が更新されるよう設計されています。これにより、CRVトークンの供給とマイニング率の透明性と公平性が保証されます。ユーザーがアクティブにエコシステムに参加することで、トークンの発行と流通が効率的かつ公正に管理されることが促進されます。

```solidity
function futureEpochTimeWrite() external returns (uint256) {
    uint256 _startEpochTime = startEpochTime;
    if (block.timestamp >= _startEpochTime + RATE_REDUCTION_TIME) {
        _updateMiningParameters();
        return startEpochTime + RATE_REDUCTION_TIME;
    } else {
        return _startEpochTime + RATE_REDUCTION_TIME;
    }
}
```